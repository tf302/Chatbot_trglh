（1）软件是一种逻辑实体，而不是具体的物理实体，因而它具有抽象性。
（2）软件的生产与硬件不同，它没有明显的制造过程。要提高软件的质量，必须在软件开发方面下功夫。
（3）在软件的运行和使用期间，不会出现硬件中出现的机械磨损、老化问题，然而它存在退化问题，必须对其进行多次修改与维护，直至其退役。
（4）计算机的开发与运行常常受到计算机系统的制约，它对计算机系统有着不同程度的依赖性。
（5）软件开发至今尚未完全摆脱人工的开发方式。
（6）软件本身是复杂的。软件的复杂性可能来自它反映的实际问题的复杂性，也可能来自程序逻辑结构的复杂性。
（7）软件成本相当昂贵。软件的研制工作需要投入大量的、复杂的、高强度的脑力劳动，它的成本是比较高的。
（8）相当多的软件工作涉及社会因素。许多软件的开发和运行涉及机构、体制及管理方式等问题，它们直接决定项目的成败。
因为，软件工程的提出是为了解决软件危机所带来的各种弊端。具体地讲，软件工程的目标主要包括以下几点。
（1）使软件开发的成本能够控制在预计的合理范围内。
（2）使软件产品的各项功能和性能能够满足用户需求。
（3）提高软件产品的质量。
（4）提高软件产品的可靠性。
（5）使生产出来的软件产品易于移植、维护、升级和使用。
（6）使软件产品的开发周期能够控制在预计的合理时间范围内。
（1）用分阶段的生命周期计划严格管理。
（2）坚持进行阶段评审制度，以确保软件产品的质量。
（3）实施严格的产品控制，以适应软件规格的变更。
（4）采用现代程序设计技术。
（5）开发出来的软件产品应该能够清楚地被审查。
（6）开发小组的人员要少而精。
（7）承认不断改进软件工程实践的必要性。
软件工程研究的内容主要包括以下两个部分。
（1）软件开发技术。主要研究软件开发方法、软件开发过程、软件开发工具和环境。
（2）软件开发过程管理。主要研究软件工程经济学和软件管理学。
软件工程包括三个要素：方法、工具和过程。
（1）软件工程方法为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等。
（2）软件工具为软件工程方法提供了自动的或半自动的软件支撑环境。目前，已经推出了许多软件工具，这些软件工具集成起来，建立起称之为计算机辅助软件工程(CASE)的软件开发支撑系统。CASE将各种软件工具、开发机器和一个存放开发过程信息的工程数据库组合起来形成一个软件工程环境。
（3）软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。
（1）达到要求的软件功能。
（2）取得较好的软件性能。
（3）开发出高质量的软件。
（4）付出较低的开发成本。
（5）需要较低的维护费用。
（6）能按时完成开发工作，及时交付使用。
（1）结构化方法。
（2）面向数据结构方法。
（3）面向对象方法。
（4）形式化方法。
Turbo Pascal；Dev C++；Codeblocks；Visual Studio；Rubymine；Webstorm；PHPstorm；PyCharm；Eclipse；IntelliJ Idea；XCode。
软件产品的生命周期是指从设计该产品的构想开始，到软件需求的确定、软件设计、软件实现、产品测试与验收、投入使用以及产品版本的不断更新，到最终该产品被市场淘汰的全过程。软件生命周期这个概念从时间的角度将软件的开发和维护的复杂过程分解为了若干个阶段，每个阶段都完成特定的相对独立的任务。由于每个阶段的任务相对于总任务难度会大幅度降低，在资源分配、时间把提和项目管理上都会比较容易控制。合理地划分软件生命周期的各个阶段，使各个阶段之间既相互区别又相互联系，为每个阶段赋予特定的任务。
瀑布、原型、増量、螺旋四个传统模型
（1）瀑布模型：主要体现了分阶段、有控制的思想。活动间强调按顺序、文档化；存在的问题是：过于理想化，每一步的工作必须完整准确，否则无法进行下一步工作。
（2）原型模型：需求分析入手快速、表达直观、容易交流。重点解决瀑布模型需求分析入手难的问题。
（3）増量模型：对于需求复杂的系统，采用分块开发，逐步集成的开发策略。増量体现了演进、迭代思想，每一块就是一个増量。每个增量是一次迭代。増量模型的新版本叫做“极限编程”（XP）。
（4）螺旋模型：融合了上述三种模型，融进了循环往复、强化了演进送代的思想，增加风险控制环节。但风险分析的正确性是左右软件演进的关键因素。
核心工作流程有业务建模、需求分析、设计、实现、测试和部署。
开发模型不是孤立或排斥的，相互借鉴和参考。在四种古典螺旋模型中，螺旋模型是一种综合性的模型，适用于较复杂的系统。
1.敏捷过程的核心价值观：（1）个体与交互高于过程和工具。（2）可运行软件高于详尽的文档。（3）与客户协作高于合同（契约）谈判。（4）对变更及时响应高于遵循计划。
2.对传统方法的“反叛”体现在以下几个方面：敏捷方法对传统方法的＂反叛“体现在以人为中心，不再依靠文档来控制过程，认为传统过程过于僵化、文档繁烦，主张对传统过程瘦身，在上述价值观的支配下，做到能够为准。
（1）软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。概括地说，软件过程描述为了开发出客户需要的软件，什么人(who)、在什么时候(when)、做什么事(what)以及怎样(how)做这些事以实现某一个特定的具体目标。
（2）软件过程是软件工程方法学的3个重要组成部分之一。
可以采用增量模型。它是瀑布模型与原型进化模型的综合，它对软件过程的考虑是：在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；但在软件的实际创建中，则把软件系统功能分解为许多増量构件，并以构件为单位逐个创建与交付，直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。
 可行性研究需要从多个方面进行评估，主要包括：战略可行性、操作可行性、计划可行性技术可行性、社会可行性、市场可行性、经济可行性和风险可行性等。
（1）战略可行性研究主要从整体的角度考虑项目是否可行，如提出的系统对组织目标具有怎样的贡献、新系统对目前的部门和组织结构有何影响、系统将以何种方式影响人力水平和现存员的技术、它对组织整个人员开发策略有何影响，等等。
（2）操作可行性研究主要考虑系统是否能够真正解決问题；系统一旦安装后，是否有足够的人力资源来运行系统；用户对新系统具有抵触情绪是否可能使操作不可行；人员的可行性等问题。
（3）计划可行性研究主要估计项目完成所需的时间并评估项目的时间是否足够。
（4）技术可行性研究主要考虑项目使用技术的成熟程度；与竞争者的技术相比，所采用技术的优势及缺陷；技术转换成本；技术发展趋势及所采用技术的发展前景；技术选择的制约条件等。
（5）社会可行性研究主要考虑项目是否满足所有项目涉及者的利益；是否满足法律或合同的要求等。
（6）市场可行性研究主要包括研究市场发展历史与发展趋势，说明本产品处于市场的什么发展阶段；本产品和同类产品的价格分析；统计当前市场的总额、竟争对手所占的份额，分析本品能占多少份额；分析产品消费群体的特征、消费方式以及影响市场的因素；分析竞争对手的市场状况；分析竞争对手在研发、销售、资金、品牌等方面的实力；分析自己的实力等。
（7）经济可行性研究主要是研究系统开发和运行需要的成本与得到的效益，分析成本效益。
（8）风险可行性研究主要是考虑项目在实施过程中可能遇到的各种风险因素，以及每种风险因素可能出现的概率和出现后的影响程度。
技术可行性主要研究待开发系统的功能、性能和限制条件，确定现有技术能否实现有关的解决方案，在现有的资源条件下实现新系统的技术风险有多大。这里的资源条件是指已有的或可以得到的软硬件资源、现有开发项目人员的技术水平和已有的工作基础。
操作可行性是对开发系统在一个给定的工作环境中能否运行或运行好坏程度的衡量。操作可行性研究决定在当前的政治意识形态、法律法规、社会道德、民族意识以及系统运行的组织机构或人员等环境下，系统的操作是否可行。操作可行性往往最容易被忽视或被低估，或者认为它一定是可行的。
成本效益分析是可行性研究的重要内容，它用于评估基于项目的经济合理性，给出项目开发的成本论证，并将估算的成本与预期的利润进行对比。
成本估算最好使用几种不同的估算技术以便相互校验。下面简单介绍两种估算技术。
（1）代码行技术，是比较简单的定量估算方法，它将开发每个软件功能的成本和实现这个功能需要使用的源代码行数联系起来。通常根据经验和历史数据估算实现一个功能所需的源代码行数。
但估算出源代码行数后，用每行代码的平均成本乘以行数即可确定软件的成本。每行代码的平均成本主要取决于软件的复杂程度和薪资水平。
（2）任务分解技术，首先将开发项目分解为若干相对独立的任务，再分别估算每个任务单独开发的成本，最后累加就可得出开发项目的总成本。
（1）明确系统的目标。
（2）分析研究现行系统。
（3）设计新系统的高层逻辑模型。
（4）获得并比较可行的方案。
（5）撰写可行性研究报告。
在可行性研究之后，就可得知一个项目是否值得开发。如果值得开发，则应制订相应的项目开发计划。项目开发计划涉及所要开发项目的各个环节。计划的合理性和准确性往往关系着项目的成功与否。计划应考虑周全，要考虑到一些未知因素和不确定因素，以及要考虑到可能的修改。计划应尽量准确，尽可能提高数据的可靠性。项目开发计划是软件工程中的一种管理性文档，主要是对所要开发软件的人员、进度、费用、软件开发环境和运行环境的配置和硬件设备的配置等进行说明和规划，是项目管理人员对项目进行管理的依据，据此对项目的费用、进度和资源进行控制和管理。
一般情况下，用户并不熟悉计算机的相关知识，而软件开发人员对相关的业务领域也不甚了解，用户与开发人员之间対同一间题理解的差异和习惯用语的不同往往会为需求分析带来很大的困难。所以，开发人员和用户之间充分和有效的沟通在需求分析的过程中至关重要。
获取需求的方法有很多种，比如，问卷调查、访谈、实地操作、建立原型和研究资料等。
问卷调查法是采用调查问卷的形式来进行需求分析的一种方法。通过对用户填写的调查问卷进行汇总、统计和分析，开发人员使可以得到一些有用的信息。一般在设计调查问卷时，要合理地控制开放式问题和封闭式问题的比例。开放式问题的回答不受限，自由灵活，能够激发用户的思维，使他们能尽可能地闻述自己的真实想法。但是，对开放式问题进行汇总和分析的工作会比较复杂。封闭式问题的答案是预先设定的，用户从若干答案中进行选择。封闭式问题便于对问卷信息进行归纳与整理，但是会限制用户的思维访谈逆过开发人员与特定的用户代表进行座谈，进而了解到用户的意见，是最直接的清求获取方法。由于被访谈的用户身份可能多种多样，开发人员要根据用户的身份特点，进行提问，给予启发。当然，进行详细的记录也是访谈过程中必不可少的工作。
结构化需求分析是一种面向数据流的需求分析方法。它基于“分解”和“抽象”的基本思想，逐步建立目标系统的逻辑模型，进而描绘出满足用户要求的软件系统。“分解”是指对于一个复杂的系统，为了将复杂性降低到可以掌握的程度，可以把大问题分解为若干个小问题，然后再分别解决。最顶层描述了整个目标系统，中间层将目标系统划分为若干个模块，每个模块完成一定的功能，而最底层是对每个模块实现方法的细节性描述。可见，在逐层分解的过程中，起初并不考虑细节性的问题，而是先关注问题最本质的属性，随着分解自顶向下进行，才逐渐考虑越来越具体的细节。这种用最本质的属性表示一个软件系统的方法就是“抽象”。
数流图的作用：数据流图可以用来抽象地表示系统或软件。从信息传递和加工的角度，它以图形的方式刻画数据流从输入到输出的移动变换过程，同时可以按自顶向下、逐步分解的方法表示内容不增加的数据流和功能细节。因此，数据流图既提供了功能建模的机制也提供了信息流建模的机制，从而可以建立其系统或软件的功能模型。
数据字典的作用：分析建模种包含了对数据对象、功能和控制的表示，在每一种表示中数据对象和控制项都扮演一定的角色。为表示每个数据对象和控制项的特性，建立了数据词典。数据词典精确地、严格地定义了每个与系统相关的数据元素，并以字典式顺序将它们组织起来，使得用户和分析员对所有的输入、输出、存储成分和中间计算有共同的理解。
ER图是用来描述某一组织(单位)的概念模型,提供了表示实体、属性和联系的方法。构成ER图的基本要素是实体、属性和关系。实体是指客观存在并可相互区分的事特；属性指指实体所具有的每一个特性。 
状态图是描述一个对象基于事件反应的动态行为，显示了该对象如何根据当前所处的状态对不同的事件作出的反应。
软件设计就是把需求规格说明书里归纳的需求转换为可行的解决方案并把解決方案反映到设计说明书里。简单的说，需求分析就是回答软件系统能“做什么”的问题，而软件设计就是要解决“怎么做”的问题。
根据用信息域表示的软件需求，及功能和性能需求，进行数据设计、系统结构设计和过程设计。
为了活动高质量的软件设计结果，应该遵循模块化、抽象、逐步求精、。信息隐藏、模块独立等基本设计原理。
软件设计可以从活动任务观点和工程管理观点分別对其进行分类。从活动任务来看软件设计是对需求进行数据设计、体系结构设计、接口设计、构件设计和部署设计。
模块是由边界元素限定的相邻的程序元素（如数据说明，可执行的语句》）的序列，而且有一个总体标识符来代表它。模块化就是把程序划分成可独立命名且独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。采用模块化原理可以使软件结构清晰，不仅容易设计也容易阅读和理解。
结构化程序设计优点由于模块相互独立，因此在设计其中一个模块时，不会受到其它模块的牵连，因而可将原来较为复杂的问题化简为一系列简单模块的设计。
（常用的结构化设计方法，多在概要设计阶段使用）它主要是指依据一定的映射规则，将需求分析阶段得到的数据描述、从系统的输入端到输出端所经历的一系列变换或出来的数据流图转换为目标系统的结构描述。
置界面于用户的控制之下、减少用户的记忆负担、保持界面的一致性。
1.简易性：界面的简洁是要让用户便于使用、便于了解、并能减少用户发生错误选择的可能性。
2.用户语言：界面中要使用能反应用户本身的语言，而不是用户界面设计者的语言，即“用户至上”原则。
3.记忆负担最小化：人脑不是电脑，在设计界面时必须要考虑人类大脑处理信息的限度。人类的短期记忆极不稳定、有限，24小时内存在25%的遗忘率。所以对用户来说，浏览信息要比记忆更容易。
4.一致性：是每一个优秀界面都具备的特点。界面的结构必须清晰且一致，风格必须要与内容相一致。
5.清楚：在视觉效果上便于理解和使用。
6.用户的熟悉程度:用户可通过已掌握的知识来使用界面，但不应超出一般常识。
7.从用户的观点考虑:想用户所想，做用户所做。用户总是按照他们自己的方法理解和使用。
8.排列:一个有序的界面能让用户轻松的使用。
9.安全性:用户能自由的作出选择，且所有选择都是可逆的。在用户作出危险的选择时有信息介入系统的提示。
10.灵活性:简单来说就是要让用户方便的使用，但不同于上述。即互动多重性，不局限于单一的工具(包括鼠标、键盘或手柄)。
11.人性化:高效率和用户满意度是人性化的体现。应具备专家级和初级玩家系统，即用户可依据自己的习惯定制界面，并能保存设置。
对数据文件的描述在逻辑上更加严密，外观结构上也更加紧凑，进而使程序员更容易把握数据文件的内容及结构。
内聚和耦合往往密切相关，模块的高内聚通常意味着低耦合。低耦合因为模块之间的耦合程度越低，相互影响就越小，发生异常后产生连锁反应的概率就越低：在修改一个模块时，低耦合的系统可以把修改范围尽量控制在最小的范田内；对“个模块进行维护时，其他模块的内部程序的正常运行不会受到较大的影响。
面向对象即按人们认识客观世界的系统思维方式，采用基于对象的概念建立模型，模拟客观世界分析、设计、实现软件的办法。通过面向对象的理念使计算机软件系统能与现实世界中的系统一一对应。面向对象的设计是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成“现实世界”的对象。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。
结构化也就是面向过程的方法：从客观事物的行为出发，肢解客观事物的整体性，从分析、设计到编程完全看不出事物的原貌。面向对象：从观察、抽象客观事物开始，就以事物原貌、事物的整体为出发点。从分析、设计、编程一直反映事物的原貌，它利用事物具有整体性、关联性、交互性、继承性和多态性的本源特征映射领域问题到计算机世界中。
（1）面向对象技术：面向对象技术强调在软件开发过程中面向客观世界或问题域中的事物，采用人类在认识客观世界的过程中普遍运用的思维方法，直观、自然地描述客观世界中的有关事物。
（2）特点：面向对象技术的基本特征主要有封装性、继承性和多态性。
（1）类是具有相似内部状态和运动规律的实体的集合。（2）类与传统的数据类型的关系：类是一种对象的抽象，是对象特性和行为的封装。 
（1）符合人类的思维习惯。通常人类在认识客观世界的事物时，不仅会考虑到事物会有哪些属性，还会考虑到事物能完成哪些操作，也就是说，静态的属性及动态的动作特征都是组成事物的一部分，它们组合起来才能完整地表达一个事物。而面向对象的软件工程方法最重要的特点就是把事物的属性和操作组成一个整体，以对象为核心，更符合人类的思维习惯。此外，面向对象的软件工程方法更加注重人类在认识客观世界时循序渐进、逐步深化的特点。
（2）稳定性好。传统的软件工程方法基于功能分析和功能分解。当软件功能发生变化时，很容易引起软件结构改变。
（3）可复用性好。面向对象技术采用了继承和多态的机制，极大地提高了代码的可复用性。从父类派生出子类，一方面复用了父类中定义的数据结构和代码，另一方面提高了代码的可扩展性。
（4）可维护性好。由于利用面向对象软件工程方法开发的软件系统稳定性和可复用性好，而且采用了封装和信息隐藏机制，易于调整局部软件，所以系统的可维护性比较好。
（1）统一标准。（2）面向对象。（3）可视化，表达能力强。（4）独立于过程。（5）容易掌握使用。（6）与编程语言的关系。
用例图主要用来图示化系统的主事件流程，它主要用来描述客户的需求，即用户希望系统具备的完成一定功能的动作，通俗地理解用例就是软件的功能模块，所以是设计系统分析阶段的起点，设计人员根据客户的需求来创建和解释用例图，用来描述软件应具备哪些功能模块以及这些模块之间的调用关系，用例图包含了用例和参与者，用例之间用关联来连接以求把系统的整个结构和功能反映给非技术人员（通常是软件的用户），对应的是软件的结构和功能分解。用例是从系统外部可见的行为，是系统为某一个或几个参与者（Actor）提供的一段完整的服务。从原则上来讲，用例之间都是独立、并列的，它们之间并不存在着包含从属关系。但是为了体现一些用例之间的业务关系，提高可维护性和一致性，用例之间可以抽象出包含(include)、扩展(extend)和泛(generalization)几种关系。
（1）包含关系：使用包含（Inclusion）用例来封装一组跨越多个用例的相似动作（行为片断），以便多个基（Base）用例复用。基用例控制与包含用例的关系，以及被包含用例的事件流是否会插入到基用例的事件流中。基用例可以依赖包含用例执行的结果，但是双方都不能访问对方的属性。
（2）扩展关系：将基用例中一段相对独立并且可选的动作，用扩展（Extension）用例加以封装，再让它从基用例中声明的扩展点（Extension Point）上进行扩展，从而使基用例行为更简练和目标更集中。扩展用例为基用例添加新的行为。扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。
（3）泛化关系：子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。在实际应用中很少使用泛化关系，子用例中的特殊行为都可以作为父用例中的备选流存在。
（1）获取需求；（2）指导测试；（3）还可在整个过程中的其它工作流起到指导作用。
（1）继承关系：继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。在Java中继承关系通过关键字extends明确标识，在设计时一般没有争议性。
（2）实现关系：实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性。
（3）依赖关系：简单的理解，依赖就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类B的变化会影响到类A。表现在代码层面，为类B作为参数被类A在某个method方法中使用。
（4）关联关系：关联体现的是两个类之间语义级别的一种强依赖关系，比如我和我的朋友，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。关联可以是单向、双向的。表现在代码层面，为被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。
（5）聚合关系：聚合是关联关系的一种特例，它体现的是整体与部分的关系，即has-a的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如计算机与CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，聚合关系以空心菱形加实线箭头表示。 
（6）组合关系：组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，组合关系以实心菱形加实线箭头表示。 
结构化需求分析方法基于“分解”和“抽象”的基本思想，逐步建立目标系统的逻辑模型，进而描绘出满足用户要求的软件系统。常用的结构化需求分析工具有数据流图、数据字典和E－R图。数据流图把软件系统看成是由数据流联系的各种功能的组合，可以用来建立目标系统的逻辑模型。数据字典用于定义数据流图中各个图元的具体内容，为数据流图中出现的图形元素做出确切的解释。E－R图可以用于描述应用系统的概念结构数据模型，它采用实体、联系和属性这三个基本概念来进行建模。面向对象需求分析方法主要基于面向对象的思想，以用例模型为基础进行需求分析。面向对象的概念中主要涉及了对象、类、封装、继承和多态等概念。因为面向对象的软件工程方法更符合人类的思维习惯，稳定性好，而且可复用性好，所以在目前的软件开发领域中最为流行。
（1）继承关系：继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。在Java中继承关系通过关键字extends明确标识，在设计时一般没有争议性。在UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。 
（2）实现关系：实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性。在UML类图设计中，实现用一条带空心三角箭头的虚线表示，从类指向实现的接口。 
（3）依赖关系：简单的理解，依赖就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类B的变化会影响到类A。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，为类B作为参数被类A在某个method方法中使用。在UML类图设计中，依赖关系用由类A指向类B的带箭头虚线表示。 
（4）关联关系：关联体现的是两个类之间语义级别的一种强依赖关系，比如我和我的朋友，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。关联可以是单向、双向的。表现在代码层面，为被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。在UML类图设计中，关联关系用由关联类A指向被关联类B的带箭头实线表示，在关联的两端可以标注关联双方的角色和多重性标记。 
（5）聚合关系：聚合是关联关系的一种特例，它体现的是整体与部分的关系，即has-a的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如计算机与CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，聚合关系以空心菱形加实线箭头表示。 
（6）组合关系：组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，组合关系以实心菱形加实线箭头表示。 
（1）定义有实际意义的对象。（2）模型的描述要规范、准确。（3）共享性。（4）封装性。
面向对象分析有五个阶段:标识对象、标识结构、标识主题、定义属性、定义服务。
动态模型，是指描述系统各量之间随时间变化而变化的规律的数学表达式。一般用微分方程或差分方程来表示。描述与操作时间和顺序有关的系统特征、影响更改的事件、事件的序列、事件的环境以及事件的组织的模型。一般用含有连续或离散时间变量的数学方程来表达。借助时序图、状态图和活动图，可以描述系统的动态模型。动态模型的每个图均有助于理解系统的行为特征。
将研究的整个地理空间看成一个空域，地理现象和空间实体作为独立的对象分布在该空域中。按其空间特征分点、线、面、体四种基本对象，每个对象对应一组相关属性。对象也可能由其他分离的对象保持特定关系，如点、线、面、体的拓扑关系。
功能模型描述了系统的所有计算。功能模型指出发生了什么，动态模型确定什么时候发生，而对象模型确定发生的客体。功能模型由多张数据流图组成。数据流图用来表示从源对象到目标对象的数据值的流向，它不包含控制信息，控制信息在动态模型中表示，同时数据流图也不表示对象中值的组织，值的组织在对象模型中表示。
软件体系结构是具有一定形式的结构化元素，即构件的集合，包括处理构件、数据构件和连接构件。处理构件负责对数据进行加工，数据构件是被加工的信息，连接构件把体系结构的不同部分组合连接起来。这一定义注重区分处理构件、数据构件和连接构件，这一方法在其他的定义和方法中基本上得到保持。
（1）规范软件开发的基本架构。（2）便于开发人员与用户沟通。（3）模块化、层次化设计，有利于减少返工，提高工作效率。（4）便于系统开发前、后期的筹备与服务。
（1）数据流风格。（2）调用/返回风格。（3）独立构件风格。（4）虚拟机风格。（5）仓库风格。
软件质量属性是指软件系统在其生存周期过程中表现出的各种特征。
（1）通过合理地划分三层结构，使各层在逻辑上保持相对独立性，提高系统的可维护性和可扩展性。（2）能更灵活地选用相应的平台和应用系统，使各层在处理负荷能力上与处理特性上分别适应各层的要求，并且这些平台和组成部分可以具有良好的可升级性和开发性。（3）应用的各层可以独立地并行开发，每层可以根据自己的特点选择适合的开发语言。（4）安全性相对较高，因为应用层屏蔽了客户直接访问数据库的权利，使得未授权用户或黑客难以绕过应用层直接获取敏感数据，为数据的安全管理提供了系统结构级的支持。
优点：耦合性低；重用性高；生命周期成本低；部署快；可维护性高；有利软件工程化管理。
缺点：没有明确的定义；不适合小型，中等规模的应用程序；增加系统结构和实现的复杂性；视图与控制器间的过于紧密的连接；视图对模型数据的低效率访问；一般高级的界面工具或构造器不支持模式。
所谓模式，就是指解决某一类相似问题的方法论。某个模式描述了一个在我们的日常生活中不断出现的问题，然后描述了该问题的解决方案的核心。人们可以使用已有的解决方案来解决新出现的问题。常见的设计模式有：工厂模式、桥接模式、策略模式。
（1）规范软件开发的基本架构。
（2）便于开发人员与用户沟通。
（3）模块化、层次化设计，有利于减少返工，提高效率。
（4）便于系统开发前、后期的筹备与服务。
结构化软件设计方法和面向对象软件设计方法是两种主流的软件设计方法。结构化软件设计方法更关注于系统的功能，采用自顶向下、逐步求精的设计过程，以模块为中心来解决问题，按照工程标准和严格的规范将目标系统划分为若干功能模块。面向数据流的方法和面向数据结构的方法是两种常用的结构化软件设计方法。面向数据流的设计方法多在概要设计阶段使用，它借助于数据流图来进行设计工作，而面向数据结构的设计方法通常在详细设计阶段使用，它按输入、输出以及计算机内部存储信息的数据结构进行软件结构的设计，从而把对数据结构的描述转换为对软件结构的描述。常用的结构化软件设工具有流程图、NS图和PAD图等。与结构化软件设计方法相比，面向对象软件设计方法的使用范田更广。与传统的软件工程方法不同的是，面向对象的方法不强调需求分析和软件设计的严格区分。从分析到设计的过渡，是一个逐渐扩充、细化和完善分析阶段所得到的各种模型的过程。面向对象的设计可以分为系统设计和对象设计两个阶段。系统设计关注于确定实现系统的策略和目标系统的高层结构，而对象设计是对需求分析阶段得到的对象模型的进一步完善、细化或扩充。
面向对象设计的启发规则是人们在长期的基于面向对象思想的软件开发实践中总结出来的经验，有利于提高开发人员设计软件的质量。启发规则具体如下。
1）设计结果应该清晰易懂。设计结果清晰易懂可以为后续的软件开发提供便利，还能够提高软件的可维护性。要做到这一点，首先应该注意对类、属性或操作的命名。如果名称能与所代表的事物或代表的含义一致，那么开发人员就能很方便地理解特定类、属性或操作的用途。要尽量避免模糊的定义。其次，如果开发闭队内已经为软件开发设立了协议，那么开发人员在设计新类时应该尽量遵循已有的协议，从而与整个系统设计保持一致。此外，如果已定义了标准的消息模式，开发人员也应该尽量遵守这些消息模式，尽量减少消息模式的数量。
（2）类等级深度应该适当。虽然类的继承与派生有诸多优点，但是不能随意创建派生类。应该使类等级中包含的层次数适当。对于中等规模的系统，类的等级层次数应该保持在5～9之间。
（3）要尽量设计简单的类。简单的类便于开发和管理。一个类过于庞大，势必会造成维护困难、不灵活等问题。为了保持类的简洁，要尽量简化对象之间的合作关系，为每个类分配的任务应该尽量简单。此外，要控制类中包含的属性及提供的操作。
（4）使用简单的协议。减少消息的参数数量是减少类间耦合程度的有效手段。一般来说，消息的参数最好控制在3个以内，而且要尽量使用简单的数据类型。
（5）使用简单的操作。控制操作中的源程序语句的行数，或语句的嵌套层数，可以简化操作。
（6）把设计的变动减至最小。虽然设计变动是正常情况，但是由于设计变动会造成资源或时间上的消耗，开发人员应该尽量把设计的变动概率降至最低。一般来说，设计的质量越高，修改设计的概率就越低，即使需要修改设计，修改的范围也会比较小。
面向对象的设计原则基本遵循传统软件设计应该遵循的基本原则，同时考虑面向对象的特点。设计原则具体如下。
1）模块化。在结构化的设计中，一个模块通常为一个过程或一个函数，它们封装了一系列的控制逻辑；而在面向对象的设计中，一个模块通常为一个类或对象，它们封装了事物的属性或操作。
（2）抽象化。类是对一组具有相似特征的对象的抽象。可以说，类是一种抽象的数据类型。同时，对象也是对客观世界中事物的抽象。它用紧密结合的一组属性和操作来表示事物的客观存在。
（3）信息隐藏。对于类而言，其内部信息，比如属性的表示方法和操作的实现算法，对外界是隐藏的。外界通过有限的接口来访问类的内部信息。类的成员都具有相应的访问控制的属性。
（4）低耦合。在面向对象的设计中，耦合主要是指对象之间的耦合，即不同对象之间相互关联的紧密程度。低耦合有利于降低由于一个模块的改变而对其他模块造成的影响。
（5）高内聚。内聚与耦合密切相关，低耦合往往意味着高内聚。提高模块的内聚性有利于提高系统的独立性。
（6）复用性。构造新类时，都需要考虑该类将来被重复利用的可能。提高类的复用性可以节约资源，精简系统结构。
（1）系统设计是根据系统分析的结果，运用系统科学的思想和方法，设计出能最大限度满足所要求的目标 (或目的) 的新系统的过程。进行系统设计时，必须把所要设计的对象系统和围绕该对象系统的环境共同考虑，前者称为内部系统，后者称为外部系统，它们之间存在着相互支持和相互制约的关系，内部系统和外部系统结合起来称作总体系统。
（2）对象设计以问题域的对象设计为核心，其结果是一个详细的对象模型。
（1）待开发系统的应用领域，即项目的应用范围。（2）用户的要求。（3）将使用何种工具进行开发。（4）开发人员的喜好和能力。（5）软件的可移植性要求。（6）算法和书记官的复杂性。（7）平台支持。
（1）版权和版本声明。（2）程序版式。（3）注释。（4）命名规则。（5）数据说明。（6）语句构造。（7）输入输出。（8）效率。
（1）机器语言：优点：直接执行，速度快，资源占用少 ；缺点：可读性、可移植性差，编程繁杂 。
（2）汇编语言：优点：能够保持机器语言的一致性，直接、简捷，目标代码简短，占用内存少，执行速度快；缺点：可维护性差，开发效率很低，周期长且单调。
（3）高级语言：优点：易学、易掌握，可维护性强，可靠性高，可移植性好，重用率高
（4）超高级语言。
（1）按照标识符的实际意义命名，使其名称具有直观性，能够体现标识符的语义。
（2）标识符的长度应当符合“最小长度与最大信息量”原则。
（3）命名规则尽量与采用的操作系统或开发工具的风格一致，如缩写的使用、字母大小写的选择、对常量和变量命名的区分等。
（4）变量名不要过于相似，这样容易引起误解
（5）在定义变量时，最好注释其含义和用途。
（6）程序中不要出现仅靠大小写区分的相似的标识符。
（7）尽量避免名称中出现数字编号，除非逻辑上的确需要编号。
（1）版本、版权声明。（2）函数接口说明。（3）重要的代码行或段落提示。
黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。
白盒测试：已知产品内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否要经过检查。
区别：
（1）在测试的方面上有所不同：软件的黑盒测试意味着测试要在软件的接口处进行。软件的白盒测试是对软件的过程性细节做细致的检查。
（2）在测试方法上存在差异：黑盒测试是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。白盒测试这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。
（3）侧重程序的错误方面上有不同：黑盒测试主要是为了发现以下几类错误：是否有不正确或遗漏的功能？在接口上，输入是否能正确的接受？能否输出正确的结果？白盒测试主要是想对程序模块进行如下检查，对程序模块的所有独立的执行路径至少测试一遍。对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。
（1）开发人员对其所写代码有主观认同感。
（2）开发人员对软件过于乐观的心态。
（3）开发人员对需求易产生偏差与混淆。
（4）开发人员擅长修复但不擅长拆解。
（5）开发人员缺乏对软件后续开发的展望。
（6）开发人员缺乏测试经验和方法。
软件测试的目的,第一是确认软件的质量，其一方面是确认软件做了你所期望做的事情，另一方面是确认软件以正确的方式来做了这个事情。第二是提供信息。第三软件测试不仅是在测试软件软件产品本身，而且还包括软件开发的过程。如果一个软件产品开发完成之后发现了很多问题，这说明此软件开发过程很可能是有缺陷的。因此，软件测试的第三个目的是保证整个软件开发过程是高质量的。 
第一步：对要执行测试的产品/项目进行分析，确定测试策略，制定测试计划。该计划被审核批准后转向第二步。测试工作启动前一定要确定正确的测试策略和指导方针，这些是后期开展工作的基础。只有将本次的测试目标和要求分析清楚，才能决定测试资源的投入。
第二步：设计测试用例。设计测试用例要根据测试需求和测试策略来进行，进度压力不大时，应该设计的详细，如果进度、成本压力较大，则应该保证测试用例覆盖到关键性的测试需求。该用例被批准后转向第三步。
第三步：如果满足“启动准则”，那么执行测试。执行测试主要是搭建测试环境，执行测试用例。执行测试时要进行进度控制、项目协调等工作。
第四步：提交缺陷。这里要进行缺陷审核和验证等工作。
第五步：消除软件缺陷。通常情况下，开发经理需要审核缺陷，并进行缺陷分配。程序员修改自己负责的缺陷。在程序员修改完成后，进入到回归测试阶段。如果满足“完成准则”，那么正常结束测试。
第六步：撰写测试报告。对测试进行分析，总结本次的经验教训，在下一次的工作中改进。
软件测试过程管理，主要包括软件测试是什么样的过程，如何评价一个软件测试过程，如何进行配置管理和测试风险分析以及测试成本的管理。
（1）完全测试时不可能的。（2）测试中存在风险。（3）软件测试只能表示缺陷存在，而不能证明软件产品已经没有缺陷。（4）软件产品中潜在的错误数与已经发现的错误数成正比。（5）让不同的测试人员参与到测试工作中。（6）让开发小组和测试小组分立，开发工作和测试工作不能由同一部分人完成。（7）尽早并不断地进行测试，使测试工作贯穿于这整个软件开发过程。（8）在设计测试用例时，应该包括输入数据和预期的输出结果两个部分，并且输入数据不仅包括合法的情况，还应该包括非法的输入情况。（9）要集中测试容易出错或错误较多的模块。
静态测试是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。
动态测试是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率和健壮性等性能，这种方法由三部分组成：构造测试实例、执行程序、分析程序的输出结果。 
从软件开发的过程按阶段划分，测试可以分为单元测试、集成测试和确认测试。
单元测试的粒度最小，一般由开发小组采用白盒方式来测试，主要测试单元是否符合“设计”。
集成测试界于单元测试和系统测试之间，起到“桥梁作用”，一般由开发小组采用白盒加黑盒的方式来测试，既验证“设计”，又验证“需求”。
确认测试则是要检查已实现的软件是否满足了需求规格说明中确定了的各种需求，以及软件配置是否完全、正确。
集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。
非增量式测试（No-Incremental Integration）也称做大爆炸集成。分别对系统中每个模块进行集成测试，然后将所有模块按层次结构图组装到一起进行测试，最终得到所要求的软件。
增量式测试的集成是逐步实现的：逐次将未曾集成测试的模块和已经集成测试的模块(或子系统)结合成程序包，再将这些模块集成为较大系统，在集成的过程中边连接边测试，以发现连接过程中产生的问题。
 项目管理： 一般意义上执行软件工程的过程就叫项目管理。 软件开发：如果实现软件功能的学问。 主要是开发语言、业务逻辑的学问。
运用科学的方法，测定估算对象的规模、所需工作量和成本。
（1）功能点（FP）估算法
功能点估算法是在需求分析阶段基于系统功能的一种规模估算方法，也叫IBM方法。这种方法适用于面向数据库应用的项目早期的规模估算，基于初始应用需求，即需求规格说明书来确定外部输入和输出数、外部接口数、用户交互数和系统要用的文件数，以获得功能点。功能点方法包括3个逻辑部分：未调整的功能点、加权因子和功能点。
（2）代码行（LOC）估算法
代码行估算往往是依据经验和组织的历史数据进行估算，多采用PERT、 Delphi、WBS、类比估算等方法。其优点是计算方便、监控容易、能反映程序员的思维能力：缺点是代码行数不能正确反映一项工作的难易程度以及代码的效率，而且编码一般只占系统开发工作量的10％左右。高水平的程序员常常能以短小精悍的代码解决问题。对于相同规模的软件，如果只用代码
行方法估算，程序员水平的改变将使估算结果失真。所以在实际中，代码行估算只是作为辅助的估算方法。
（1）Gantt图。（2）PERT图。
民主制程序员组、主程序员组和现代程序员组。
优点主要有:主程序员广播式发布工作要求,组织管理好、效率高、质量容易保证、成本相对较低。
缺点主要有:人员完整配备较难、不利人才脱颖而出。并且,能够在技术和管理两方面都能同时具备优秀品质的主程序员更不多见。
（1）民主制：小组人多的话，通信量会非常大；如果组内多数成员技术水平不高，或是缺乏经验的新手，就很可能不能完成项目。
（2）主程序员制：程序太死板，规定好了就不会人性化的缓冲。
分为六步：确定风险关注点、估计损失大小、评估损失的概率、计算风险暴露量、实施整个项目的延期和实施整个项目的缓冲。
软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。
（1）面向CMM2的KPA”软件质量保证“（SQA：Software Quality Assurance）方法。
（2）面向CMM3的KPA”同行评审“（PR：Peer Reviews）方法。
（3）面向CMM4的KPA“软件质量管理”（SQM：Software Quality Management）方法。
（4）面向CMM5的KPA“缺陷预防”（DP：Defect Prevention）方法。
（5）软件质量保证的其他措施。
SCM的目标一般包括以下几项：配置识别：识别配置、配置项目和基准。
配置控管：导入变更控管流程。该流程通常由变更控制委员会来运行，其主要的职责是核准或拒绝有悖任何基准的所有变更请求。
    配置状态报告：记录和呈报与开发过程状态相关的所有必要信息。
    配置审核：确保这些配置包含所有预期内容，且备有完整的规定文件（包括要求、结构规范和用户手册）。
    建构管理：管理用于建构的流程和工具。
    流程管理：确保遵循企业组织的开发流程。
    环境管理：管理承载系统的软硬件。
    团队合作：促进流程中团队彼此间的交互。
    缺陷追踪：确保可溯及每个缺陷的源头。
随着云计算的引进，SCM工具的用途有时已互相集成。SCM工具本身转变为虚拟设施，可以在虚拟机上运行并保存状态和版本。这些工具能管理并为云端虚拟资源（包括虚拟设备、存储设备和软件包）创建模型。如今，因为现在已经可以动态的激活虚拟服务器和相关资源，SCM管理人员的角色和职责已经与开发人员合并。
1．标识配置项
配置项是配置管理中的基本单元，每个配置项应该包含相应的基本配置管理信息。标识配置项就是给配置项取一个合适的名字。所有的软件产品都要标识配置项，该标识符应该具有唯一性并且要遵循特定的版本命名规律，以便于管理和追踪。
2．配置控制
配置控制是配置管理的关键，包括访问控制、版本控制、变更控制和产品发布控制等。
（1）访问控制通过配置管理中的“软件开发库”“软件基线库”和“软件产品库”实现，每个库对应不同级别的操作权限，为团队成员授予不同的访问权利。
（2）版本控制是指用户能够选择适当的版本，从而获得需要的系统配置，版本控制往往使用自动的版本控制工具来实现。
（3）变更控制是应对软件开发过程中各种变化的机制，可以建立控制点和报告与审查制度来实现。
（4）产品发布控制面向最终发布版本的软件产品，旨在保证提交给用户的软件产品版本是完整、正确和一致的。
3．记录配置状态
记录配置状态的目的是使配置管理的过程具有可追踪性。配置状态报告记录了软件开发过程中每一次配置变更的详细信息，包括改动的配置项、改动内容、改动时间和改动人等。配置状态报告是开发人员之间进行交流的重要工具，对项目的成功非常重要。
4．执行配置审计
配置审计是为了保证软件工作产品的一致性和完整性，从而保证最终软件版本产品发布的正确性。
软件维护是软件产品生命周期的最后个阶段在产品交付并且投入使用之后，为了解决在使用过程中不断发现的各种问题，保证系统正常运行，同时使系统功能随着用户需求的更新而不断升级，软件维护的工作是非常必要的。概括地说，软件维护就是指在软件产品交付给用户之后，为了改正软件测试阶段末发现的缺陷，改进软件广品的性能，补充秋件产品的新功能等，所进行的修改软件的过程。
①修改编码：使编码更加混乱，程序结构更不清晰，可读性更差，而且有连锁反应。
②修改数据结构：数据结构是系统的骨架，修改数据结构是对系统伤筋动骨的大手术，在数据冗余与数据不一致方面，可能顾失彼。
③修改用户数据：需要与用户协商，一旦有疏忽，可使系统发生意外。
④修改文档：对非结构化维护不适应，对结构化维护要严防程序与文档的不匹配。
软件文档(Document)也称文件，通常是指的是一些记录的数据和数据媒体，它具有固定不变的形式，可被任何计算机阅读。在软件工程中，文档常常用来表示对活动、需求、过程或结果进行描述、定义、规定或认证的任何书面或图示的信息，他们描述和规定了软件设计和实现细节，说明使用软件的操作命令。
文档是软件产品的一部分，没有文档的软件就不称其为软件。软件文档的编制在软件开发工作中占有突出的地位和相当大的工作量。高质量和高效的开发、分发、管理和维护文档对于转让、变更、修正、扩充和使用文档，对于充分发挥软件产品的效益有着重要的意义。
很据上述，应该选择主程序员组的项目组结构。因为项目小组以前做过类似的系统，开发人员已经具备了一定的经验。
